<center><font size=6 color=blue>Linux</font></center>

[toc]

# 1.虚拟机和Ubuntu安装

虚拟机使用VMware，[软件安装管家](https://mp.weixin.qq.com/s/1SvtBI1hEW8CBSOi2N0IFQ)有详细安装步骤。

在[Ubuntu官网](https://ubuntu.com/#download)上下载Ubuntu18.04。

在虚拟机中参考(https://zhuanlan.zhihu.com/p/38797088)进行配置。

**遇到的问题**：

* 无网络

  点击==虚拟机-设置-网络适配器==，网络连接选为NAT模式。

  * 使用`apt-get update`来获取程序更新信息。注意：本步是未装网络工具需要进行，如果没有root权限，使用`sudo`。
  * 使用`apt install net-tools`来安装网络工具组件。注意：本步是未装网络工具需要进行，如果没有root权限，使用`sudo`。
  * 使用`ifconfig`查看网络基本信息。可以看到，网卡和相应的IP信息等。
  * 使用`ifconfig 网卡名 down`可关闭使用中的网卡。
  * 使用`ifconfig 网卡名 up`可打开使用中的网卡。

  一般就能连上网，或者重启系统试试。实在不行请教网上大神。

# 2.桌面自适应

正常安装在虚拟机的Ubuntu桌面是位于屏幕中央，并未填充整个屏幕，为实现桌面自适应，依次点击==查看-自动调整大小-自动适应客户机==，若桌面没变化，点击==虚拟机-安装VMware-tools==，安装完成后，桌面会出现VMware Tools的图标，双击这个.iso文件，出现目录VMware Tools，把里面的***.tar.gz文件复制到主目录。

在命令界面中，输入`tar -zxvf VMwaretools***.tar.gz`，与得到的***.tar.gz文件名称一致。

再输入`cd VMwaretools***`，进入该工具解压后的目录里面，最后输入`sudo ./vmware-install.pl`执行，一路回车或按提示输入命令，即可安装成功，安装成功后，就能自动适应客户机了，`CTRL+Alt+enter`键就能给ubuntu全屏。

# 3.常用命令

具体的shell命令用法可以通过`help` 或 `man`命令进入手册来查询其具体用法。

命令行提示符`$`表示普通用户，`#`表示root用户。

设置root：

```
sudo passwd root     设置root账户的密码
sudo su
su root   均可切换到root，输入密码（Linux中输入密码不可见）
exit	退出root
```

几个技巧：
Tab键： 补全命令、参数
Ctr+c: 强行终止当前程序
Ctr+z: 将当前程序放到后台，拖回前台输入命令 fg
Ctr+a: 将光标输入行头，相当于home键
Ctr+e: 将光标输入行末，相当于end键

**正则表达式**是一种符号表示法，被用来识别文本模式。在某种程度上，它们与匹配文件和路径名的 shell通配符比较相似，但其规模更大。形式和功能上正则表达式和通配符很像，不过它们之间又有很大差别，特别在于一些特殊的匹配字符的含义上，比如*在通配符中表示匹配0或多个字符，而在正则表达式中为匹配之前字符串的0次或多次。
正则表达式元字符由以下字符组成：

![image-20201015175519736](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20201015175519736.png)

如，利用 Linux 系统自带的字典查找一个五个字母的单词，第三个字母为 j,最后一个字母为
`r grep '^..j.r$' /usr/share/dict/words`
验证固定电话，打印符合条件的电话，区号：前面一个 0，后面跟 2-3 位数字 ： 0[0-9]{2,3}；电话号码：7-8 位数字： [0-9]{7,8}；分机号：一般都是 3-4 位数字： [0-9]{3,4}
`grep -E “^0[0-9]{2,3}-[0-9]{7,8}(-[0-9]{3,4})?​” telephone.txt`
不加`-E` 选项时执行命令时没有任何匹配输出，那上例没加为什么可以呢，这是因为 上例中使用基本正则表达式即可正确匹配，而此例中需要使用拓展正则表达式。

## 3.1.常见Shell命令

### 3.1.1.**pwd** (printing working directory)

显示当前目录
格式为： `pwd [参数]`
可选参数为
`-P` 显示物理地址，为默认值
`-L` 目录为连接路径时，显示连接路径

### 3.1.2.**wc** (word count)

wc命令用来计算数字。利用wc指令我们可以计算文件的Byte数、字数或是行数，若不指定文件名称，或是
所给予的文件名为“-”，则wc指令会从标准输入设备读取数据。
格式为： `wc [选项] [文件]`
选项有：`-c`（只显示Bytes数） `-l`（只显示行数） `-w`（只显示字数）
 `-m`(统计字符数) `-L`(打印最长行行数）
如，统计/bin 目录下的命令个数
`ls /bin | wc -l`

### 3.1.3.**cd** (change directory)

切换当前目录至指定目录
格式为： `cd [目录名]`
有几个特殊参数
`/` 系统根目录
`.` 当前系统目录
`..` 当前目录的父目录
`～` 当前用户主目录,即 /home/maroon目录
`\-`上次所在目录

### 3.1.4.**ls** (list)

列出对应目录清单
格式为： `ls [选项] [目录名]`
常用选型有 
`-a`（列出目录下所有文件） `-l`（除文件名外，打印包括文件权限、大小等详细信息)
`-d`（directory,显示文件夹即可，不显示其下具体文件） `-h`(human-readable,以容易理解的方式列出文件大小，1k=1048） `-t`(按时间顺序排列）
目录名缺省为当前目录
如，列出/home 文件夹下的所有文件和目录的详细资料
`ls -al /home`
以容易理解的格式列出/home 目录中所有以”m”开头的文件目录的大小
`cd /home`
`ls -lh m*`

### 3.1.5.**mkdir** (make directory)

创建目录名
格式为： mkdir [选项] [目录名]
选项有 
-m(mode,设置权限） 
-p(parents,创建多个目录） 
-v(verbose,每次创建新目录都显示信息）
如，一次创建多个目录,并且显示具体创建信息
`mkdir -vp temp/text`
创建权限为777的目录
`mkdir -m 777 temp`

### 3.1.6.**touch**

touch命令有两个功能：一是用于把已存在文件的时间标签更新为系统当前的时间（默认方式），它们的数据将原封不动地保留下来；二是用来创建新的空文件。
格式为：`touch [选项] [文件]`
参数有： `-a`(只更改存取时间） `-c`（不创建文件） `-d<时间日期>`/`-t<日期时间>`(使用指定的时间)	`-m`（只更改变动时间）
如，创建文件ex2
`touch ex2`

### 3.1.7.**rm** (remove)

删除目录中的文件或目录，对于链接文件，只删除链接
格式为： `rm [选项] [文件或目录名]`
选项有 `-f`(force,忽略不存在的文件，不给提示） `-i`(interactive,交互式删除） `-v`(verbose,详细显示步骤）`-r`（递归）
如，删除后缀名为.log的所有文件，删除前逐一询问
`rm -i *.log`
删除/var/log/httpd/access目录以及其下所有文件、文件夹：
`rm -rf /var/log/httpd/access`

### 3.1.8.**mv** (move)

移动或更改文件名，常用来备份文件或目录
格式为: `mv [选项] [源文件或目录] [目标文件或目录]`
选项有 `-b`(back,覆盖前先备份） `-f`(force,强行覆盖） `-i`(interactive，询问是否覆盖）`-u`(update,目标文件已经存在，源文件较新时更新） `-t`(target,移动多个源文件到一个目录下，此时目标目录在前，源文件在后）
如，将文件 a.txt 移动到 test1 目录下，如果文件存在，覆盖前会询问是否覆盖，
`mv -i a.txt test1` (test1目录已经存在，否则会执行重命名）
`sudo mv opencv-3.3.1/ opencv-3.3.1-dev`

### 3.1.9.**cp** (copy)

复制文件或目录
格式为：`cp [选项] [源文件] [目录]`
选项有 `-t`(target,指定目标目录， 此时目标目录在前，源文件在后） `-i` `-f` `-u` `-n`（no-clobber,不要覆盖已存在的文件） `-s`(symbolic-link，建立源文件的符号链接，而非复制文件）`-r`(复制文件夹)
如将 test1目录下的所有文件复制到test2目录下，覆盖前询问,可以使用如下命令：
`cp -i text1/* text2`

### 3.1.10.**cat** (concatenate)

将文件或标准输入组合输出到标准输出，常用来显示文件内容或连接文件，反向显示文件内容命令为`tac`
格式为： `cat [选项] [文件]`
常用参数有： `-A`（show-all) `-b`(number-nonblank,对非空输出行编号）
`-n`(number,对所有输出行进行编号） `-s`(squeeze-blank,多个空白行转换为一个空白符）
如，把 a.log 的文件内容加上行号后输入b.log 这个文件里，多行空行换成一行输出
`cat -ns a.log > b.log`

### 3.1.11.**nl** (number of lines)

计算文件中的行数
格式为： `nl [选项] [文件]`
选项有 `-b a` (空行也列出行号，类似于`cat -n`) `-b t`(空行不列行号，默认值） `-w`(行号栏位的位数）
`-n ln`(行号在自己栏位的最左方显示） `-n rn`(行号在自己栏位的最右方显示，不加0) `-n rz`(行号在在自己栏位的最右方显示，加0)
如，把a.log 的文件内容加上行号后显示，行号在屏幕最右方加 0 显示，行号栏目占位数为 3
`nl -n rz -w 3 a.log`

### 3.1.12.**more**

功能类似于cat，cat将文件内容从上到下显示，more命令一页页显示，方便阅读，按空格键往下翻，按`b`（back)键显示上一页，`=`键输出当前行号，`q`键退出more。此外还可以搜索字符串
格式为： `more [选项] [文件]`
参数有： `+n`(从第n行开始显示） `-n`(定义屏幕大小为n行） `+/pattern`(在文件显示前搜寻字符串pattern,从该字符串前两行开始显示）
如，从 a.log 文件中查找第一个出现"g"字符串的行，并从该处前两行开始显示输出，规定每屏的行数为5
`more -5 +/g a.log`

### 3.1.13.**less**

也是对文件及输出的显示工具，功能极其强大
格式为： `less [选项] [文件]`
常用参数为 `-f`(强迫打开) `-i`(忽略大小写） `-N`（显示每列行号） `-s`(显示连续空行为一行）
常用操作：`/`字符串 向下搜索字符串 `？`字符串 向上搜索字符串
如，显示 a.log 文件中的内容，搜索字符串”hello”，可以使用如下命令
`less a.log`
`/hello`
**less 与 cat 和 more 的区别：**
cat 命令功能用于显示整个文件的内容，单独使用没有翻页功能。因此经常和 more 命令搭配使用，cat命令还有就是可以将数个文件合并成一个文件的功能。 
more 命令功能：让画面在显示满一页时暂停，此时可按空格健继续显示下一个画面，或按 q 键停止显示。
less 命令功能：less 命令的用法与 more 命令类似，也可以用来浏览超过一页的文件。所不同的是
less 命令除了可以按空格键向下显示文件外，还可以利用上下键来卷动文件。当要结束浏览时，只要在
less 命令的提示符“：”下按 q 键即可。 其实这三个命令除了 cat 命令有合并文件的功能，其余功能上
相近，只是从浏览习惯和显示方式上有所不同。

### 3.1.14.**head**

显示文件开头，默认为10行,对应于tail命令（显示文件末尾内容）
格式为： `head [选项] [文件]`
选项有 `-q`(隐藏文件名） `-v`(显示文件名) `-c`<字节数>(显示字节数) `-n`<行数>(显示行数，参数为负时显示文件末尾行）
如，显示 a.log 和 b.log 文件中的前 5 行内容，可以使用如下命令：
`head -n 5 a.log b.log`

### 3.1.15.**which**

在PATH变量指定的路径中搜索可执行文件的所在位置，一般用来确认系统中是否正确安装了指定软件如，确认是否正确安装了gcc
`which gcc`

### 3.1.16.**whereis**

定位文件，还可搜索源代码，指定备用搜索路径和搜索不寻常项的能力。whereis 命令查找速度非常快，这是因为它根本不是在磁盘中漫无目的乱找，而是在一个数据库中（/var/lib/mlocate/）查询。这个数据
库是 Linux 系统自动创建的，包含有本地所有文件的信息，并且每天通过自动执行updatedb 命令更新一次。也正是因为这个数据库要每天才更新一次，就会使得 whereis 命令的搜索结果有时候会不准确，比如刚添加的文件可能搜不到
格式为: `whereis [选项] [文件]`
常用参数： `-b`（定位可执行文件） `-m`(定位帮助文件） `-s`(定位源代码文件)
如，搜索gcc帮助文件的路径
`whereis -m gcc`

### 3.1.17.**locate**

与whereis命令类似，且使用相同的数据库。但 whereis 命令只能搜索可执行文件、联机帮助文件和源代码文件，如果要获得更全面的搜索结果，可以使用 locate 命令。
格式： `locate [选项] [搜索字符串]`
参数 `-q`(quiet,不显示出错信息） `-n`(至多显示n个输出) `-r`(使用正则表达式作搜索条件）
如，搜索 etc 目录下所有以 sh 开头的文件，可以使用如下命令：
`locate /etc/sh`
`locate rosdep`

### 3.1.18.**find**

沿文件层次结构向下遍历，匹配符号条件的文件，并执行相应操作，其功能非常强大
格式为： `find [搜索路径] [表达式]`
默认路径是当前目录，默认表达式为 -print
常用参数有 `-print`(输出到标准输出) `-delete`（删除搜索到的文件) `-exec`(对匹配的文件执行参数给出的shell命令) `-name`(按文件名查找文件） `-type`(按类型查找文件,常用文件类型有`b`(块设备文件）、`c`（字符设备文件）、`d`(目录）、`f`(普通文件）、`l`（符号链接）） 
`-perm`（根据文件权限查找文件）`-user`（所有者选项） `-mtime -n +n`(按照文件更改时间查找文件，-n表示更改时间小于n天，+n表示更改时间大于n天) 
`-size +10k/-10k/10k`(搜索大于/小于/等于10k的文件)
此外还可使用逻辑操作符 `-add -or -not ()`(圆括号字符在shell中有特殊含义，所以在命令中使用它们的时候需要引起来，通常使用\转义字符）
如，打印当前目录下所有以.txt 结尾的符号链接
`find . -type l -name “.txt” -print`
打印当前目录下所有权限为 777 的 php 文件（web 服务器上的 php 文件一般需要执行权限）
`find . -type f -name “.php” -perm 777`
打印当前目录下 root 用户拥有的所有文件
`find . -type f -user root`
打印当前目录下权限不是 777 和 664 的所有文件
`find . -type f \( ! -perm 777 -and ! -perm 644 \)`
现在想要把所有 c 语言代码文件下载下来，如果一个一个的下载很麻烦，我们可以先查找到所有的 c 语言代码文件，然后将这些文件内容写入到一个文件中，下载该文件
`find . -name “*.c” -exec cat {} \; > all.c`
在这里说明一下{}和\;，{}其实它就是一个占位符，在 find 命令的执行过程中会不断地替换成当前找到的文件.而\;是-exec 的命令结束标记，因为规定-exec 后面的命令必须以;结束，但;在 shell 中有特殊含义，必须要转义，所以写成\;。

### 3.1.19.**xargs**

xargs命令可以从标准输入接收输入，并把输入转换为一个特定的参数列表
格式为： `command | xargs [选项] [command]`
常用参数 `-n`（指定每行最大的参数数量) `-d`（指定分隔符)
如，`echo "nameXnameXnameXname" | xargs -dX -n2`
查找当前目录下所有 c 代码文件，统计总行数，可以使用如下命令
`find . -type f -name “.c” | xargs wc -l`
将find产生的输出（test2目录下的所有tes文件），作为rm的参数，从而完全删除
`find test2/ -name ‘.tes’ |xargs rm -rf`

### 3.1.20.**grep** （global search regular expression(RE) and print out the line)

一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。
格式为： `grep [选项] pattern [file]`
常用参数：`-c`(计算搜索到字符串即pattern的次数） `-i`(忽略大小写） `-n`(输出行号） `-v`(反向选择，打印不匹配的行） `-r`（递归搜索) `-E`(将范本样式为延伸的普通表示法来使用，意味着使用扩展正则表达式) `–color=auto`(找到的关键字加颜色显示) `-o`(只打印匹配项，一个个按列显示）
如，将/etc/passwd 文件中出现 root 的行取出来，关键词部分加上颜色显示：
`grep “root” /etc/passwd --color=auto` 或
`cat /etc/passwd | grep “root” --color=auto`
将/etc/passwd 文件中没有出现 root 和 nologin 的行取出来:
`grep -v “root” /etc/passwd | grep -v “nologin”`
在当前目录下递归搜索文件中包含 main()的文件(经常用于查找某些函数位于哪些源代码文件中)
`grep -r “main()”` 

### 3.1.21.**cut**

cut 命令是一个将文本按列进行切分的小工具，它可以指定分隔每列的定界符。如果一行数据包含多个字段（多列），现在想要提取其中的一列或多列，这是 cut 命令就可以大显身手了。
格式为：`cut [选项] [文件名]`
常用参数有： `-b`（以字节为单位分割) `-c`(以字符为单位分割,-c -5前五个，-c 5- 前五个之后的,-c 5 第五个，-c 2-5 第二个到第五个） `-d`(自定义分隔符，默认为制表符) `-f`(自定义字段，如一列和三列-f 1，3、第一列-f 1、前三列-f 1-3） -complement（抽取除-c,-f指定的文本外的整个文本行)
如，取出 student.txt 文件中除第一列的其他列
`cut -f 1 -d ‘ ’ student.txt –complement`

### 3.1.22.**sed**

与vim不同，sed属于流编辑器，即在编辑文件的时候不用把整个文件都读入内存，可以一行行读入，操作完成后再读入下一行，可以占用较小的内存资源。
格式为： `sed [选项] [操作] [文件名]`
如将 /etc/passwd 的内容列出并且列印行号，同时，请将第 2~5 行删除：
`nl /etc/passwd | sed ‘2,5d’`
与grep一样，sed也支持特殊元字符，来进行模式查找、替换。不同的是，sed使用的正则表达式是括在斜杠线"/"之间的模式。如果要把正则表达式分隔符"/"改为另一个字符，比如o，只要在这个字符前加一个反斜线，在字符后跟上正则表达式，再跟上这个字符即可。例如：`sed '\o^Myop' datafile`

### 3.1.23.**paste**

paste 命令的功能正好与 cut 相反。它会添加一个或多个文本列到文件中，而不是从文件中抽取文本列。
格式为： `paste [选项] [文件名]`
常用参数有 `-s`(将每个文件合并成行，而不是单独粘贴) `-d`(自定义分隔符，默认为制表符)
如，将 student.txt 和 telphone.txt 文件中的内容按列拼接，指定分隔符为’：’
`paste student.txt telphone.txt -d ‘:’`

### 3.1.24.**tr** (translate)

tr 命令常被用来更改字符。我们可以把它看作是一种基于字符的查找和替换操作。换字是一种把字符从一个字母转换为另一个字母的过程。tr 从标准输入中替换、缩减和/或删除字符，并将结果写到标准输出。
格式为： `tr [选项] SET1 SET2`
常用参数 `-d` 删除匹配SET1的内容，不作替换
如，将输入的字符大写转换为小写
`echo 'THIS IS Maroon!' | tr 'A-Z' 'a-z'`
将输入的字符中的数字删除
`echo 'THIS 123 IS Maroon!' | tr -d '0-9'`

### 3.1.25.**sort**

对于文件及标准输入的文本进行从小到大排序
格式为： `sort [选项] [文本名]`
常用参数为 `-n`(基于字符串长短来排序) `-k`（指定排序关键词) `-b`(排序时忽略每行开头空格) `-r`(以相反顺序即降序排列) -t(自定义分隔符，默认为制表符)
如，列出/usr/bin/目录下使用空间最多的前 10 个目录文件
`ls -l /usr/bin/ | sort -nr -k 5 | head -n 10`

### 3.1.26.**uniq** (unique)

uniq命令用于报告或忽略文件中的重复行，只能用于排过序的数据 ，常与sort命令结合使用。
格式为： `uniq [选项] [文件名]`
常用参数有 `-c`(在每行前加上出现次数的标号) `-d`（只输出重复出现的行） 
`-u`(只显示唯一的行)
如，找出/bin 目录和/usr/bin 目录下所有相同的命令
`ls /bin /usr/bin | sort | uniq -d`

### 3.1.27.**join**

join命令用来将两个文件中，制定栏位内容相同的行连接起来。找出两个文件中，指定栏位内容相同的行，并加以合并，再输出到标准输出设备。与uniq命令相同，常能用于排过序的数据。
格式为 `join [选项] 文件1 文件2`
常用参数 `-j FIFLD`（等同于-1 FIFLD -2 FIFLD，两个文件匹配字段相同)
如，指定两个文件的第三个字段为匹配字段，连接两个文件
`join -1 3 -2 3 c.txt d.txt`

### 3.1.28.**common**

逐行比较文本文件，显示结果包括 3 列：第 1 列为只在第一个文件中找到的行，第 2 列为只在第二个文件中找到的行，第 3 列为两个文件的共有行。与uniq,join相同，只能用于排过序的数据
格式为 `common [选项] 文件1 文件2`
参数有 `-1`（不能输出文件1特有的行） `-2`（不能输出文件2特有的行） `-3`（不输出两个文件共有的行）
如，比较 file1.txt 和 file2.txt 两个文件的内容，只显示两个文件共有的内容
`common -12 file1.txt file2.txt`

### 3.1.29.**diff** (differential）

diff命令在最简单的情况下，比较给定的两个文件的不同。如果使用“-”代替“文件”参数，则要比较的内容将来自标准输入。diff命令是以逐行的方式，比较文本文件的异同处。如果该命令指定进行目录的比较，则将会比较该目录中具有相同文件名的文件，而不会对其子目录文件进行任何比较操作。
格式为： `diff [选项] 文件`
常用参数有 `-c`(上下文模式） `-u`（统一模式） `-a`（逐行比较） `-r`（递归比较目录下的文件）

### 3.1.30.**patch**

patch 命令被用来把更改应用到文本文件中。它接受从 diff 程序的输出，并且通常被用来把较老的文件版本转变为较新的文件版本。让我们考虑一个著名的例子。Linux 内核是由一个大型的，组织松散的贡献者团队开发而成，这些贡献者会提交固定的少量更改到源码包中。这个 Linux 内核由几百万行代码组成，虽然每个贡献者每次所做的修改相当少。对于一个贡献者来说，每做一个修改就给每个开发者发送整个的内核源
码树，这是没有任何意义的。相反，提交一个 diff 文件。一个 diff 文件包含先前的内核版本与带有贡献者修改的新版本之间的差异。然后一个接受者使用 patch 程序，把这些更改应用到他自己的源码树中。
使用 diff/patch 组合提供了两个重大优点：
一个 diff 文件非常小，与整个源码树的大小相比较而言。
一个 diff 文件简洁地显示了所做的修改，从而允许程序补丁的审阅者能快速地评它。
当然，diff/patch 能工作于任何文本文件，不仅仅是源码文件。它同样适用于配置文件或任意其它文本。
准备一个 diff 文件供 patch 命令使用，GNU 文档建议这样使用 diff 命令：
`diff -Naur old_file new_file > diff_file`
old file 和 new file 部分不是单个文件就是包含文件的目录。这个 r 选项支持递归目录树。
格式为： `patch [选项] 补丁文件`
常用参数有 `-p num`(忽略几层文件夹) `-E`(发现空文件时删除） `-R`（取消打过的补丁）
如，生成 file1.txt 和 file2.txt 的 diff 文件，然后应用 patch 命令更新 file1.txt 文件
`diff -Naur file1.txt file2.txt > patchdiff.txt`
`patch < patchdiff.txt`
取消上边打的补丁
`patch -R < patchdiff.txt`

### 3.1.31.**df** (disk free)

estimate file space usage，检查linux服务器的文件系统的磁盘空间占用情况
格式为： `df [选项] 文件`
参数 `-a`(全部文件系统列表) `-h`(方便阅读显示) `-i`(显示inode信息) `-T`(文件系统类型) `-t<文件系统类型>`(只显示选定文件系统的磁盘信息） `-x<文件系统类型>`(不显示选定文件系统的磁盘信息）
如，指定类型磁盘
`df -t ext4`

### 3.1.32.**du** (disk usage)

estimate file space usage，与df不同，du是对文件和目录使用空间的查看
格式为： `du [选项] 文件`
参数为 `-a`(显示目录中个别文件的大小） `-b`（显示大小时以byte为单位) `-k`(以KB为单位） `-m`（以MB为单位） `-s`（仅显示总计，列出最后加总的值） `-h`（以K，M，G为单位，提高可读性)`-c`（除显示单独目录大小外，显示所有目录与文件总和)
如，显示几个文件或目录各自占用磁盘空间的大小，并且统计总和
`du -ch file1.txt file2.txt`
按照空间大小逆序排序显示
`du -h | sort -nr | head -10`(等同于head -n 10)

### 3.1.33.**time**

测量一个命令的运行时间
格式为：`time 命令`
如，将命令date的运行时间保存到本地文件中
`{ time date; } 2> 1.txt`

### 3.1.34.**clear**

清屏

## 3.2.Linux文件的基本操作

### 3.2.1.新建

**新建空白文件**
使用 touch 命令创建空白文件，关于 touch 命令，其主要是来更改已有文件的时间戳的（比如，最近访问时间，最近修改时间），但其在不加任何参数的情况下，只指定一个文件名，则可以创建一个为指定文件名的空白文件（不会覆盖已有同名文件）在当前目录。
如在主目录创建test空白文件
`cd ~`
`touch test`
**新建目录**
使用 mkdir（make directories）命令可以创建一个空目录,也可同时指定创建目录的权限属性。使用 `-p` 参数，同时创建父目录（如果不存在该父目录），这在有时候安装软件，配置安装路径时非常有用：
`mkdir -p father/son/grandson`

### 3.2.2.复制

**复制文件**
使用cp（copy）命令复制一个文件或目录到指定目录。将之前创建的"test"文件复制
到"/home/shiyanlou/father/son/grandson"目录中：
`cp test father/son/grandson`
**复制目录**
要成功复制目录需要加上-r或者-R参数，表示递归复制：
`mkdir family`
`cp -r father family`

### 3.2.3.删除

**删除文件**
使用rm（remove files or directories）命令，删除一个文件或目录,遇到想要删除一些为只读权限的文件，直接使用rm删除会显示一个提示,如果想忽略这提示，直接删除文件，可以使用-f参数强制删除：
`rm -f test`
**删除目录**
跟复制目录一样，要删除一个目录，也需要加上-r或-R参数：
`rm -r family`

### 3.2.4.移动文件与文件重命令

**移动文件**
使用mv(move or rename files)命令，移动文件（剪切）。如将文件"file1"移
到"Documents"目录，格式为 mv 源目录文件 目的目录：
`mkdir Documents`
`mv file1 Documents`
**重命名文件**
将文件"file1"重命名为"myfile" mv 旧的文件名 新的文件名：
`mv file1 myfile`

### 3.2.5.查看文件

使用cat,tac和nl命令查看文件
这两个命令都是用来打印文件内容到标准输出（终端）,其中cat为正序显示，tac倒序显示。
比如我们要查看passwd文件：
`cat passwd`
可以加上-n参数显示行号：
`cat -n passwd`
nl命令，添加行号并打印，这是个比`cat -n`更专业的行号打印命令
`nl passwd`
使用这几个命令，默认的终端窗口大小，一屏显示不完文本的内容，得用鼠标拖动滚动条或者滑动滚轮才能继续往下翻页，要是可以直接使用键盘操作翻页就好了，那么就可以使用`more`和`less`命令分页查看文件。
如果说上面的 cat 是用来快速查看一个文件内容的，那么这个more和less就是天生用来"阅读"一个文件的内容的，比如说"man"手册内部就是使用的 less 来显示内容。其中more命令比较简单，只能向一个方向滚动，而"less"为基于"more"和"vi"(一个强大的编辑器)开发，功能更强大。less 的使用基本和 more 一致
使用more工具打开passwd文件：
`more passwd`
打开后默认只显示一屏内容，终端底部显示当前阅读的进度(百分比)。可以使用`Enter`键向下滚动一行，使用`Space`键向下滚动一屏，按下h显示帮助，q退出。
使用`head`和`tail`命令查看文件，它们是只查看的头几行（默认为10行，不足10行则显示全部）和尾几行，改变查看的行数， 加上-n参数，后面紧跟行数：
`tail -n 1 /etc/passwd`

### 3.2.6.查看文件类型

==在 Linux 下面文件的类型不是根据文件后缀来判断的==，通常使用file命令可以查看文件的类型：
`file /bin/ls`

### 3.2.7.编辑文件

在 Linux 下面编辑文件通常我们会直接使用专门的命令行编辑器比如（emacs，vim，nano）,vim编辑器有三种常用的模式
**普通模式**
在普通模式中，用的编辑器命令，比如移动光标，删除文本等等。这也是Vim启动后的默认模式。
**插入模式**
在这个模式中，大多数按键都会向文本缓冲中插入文本
**命令行模式**
在命令行模式中可以输入会被解释成并执行的文本。
**三种常用模式的切换**：vim启动进入普通模式，处于插入模式或命令行模式时只需要按Esc进入普通模式，普通模式中按i（插入）键都可以进入插入模式，普通模式中按:进入命令行模式。命令行模式中输入wq回车后保存并退出vim，后边加感叹号!强制保存退出。

## 3.3.Linux下的帮助命令

### 3.3.1.内建命令与外部命令

**内建命令**实际上是 shell 程序的一部分，其中包含的是一些比较简单的 Linux 系统命令，这些命令是写在bash源码的builtins里面的，并由 shell 程序识别并在 shell 程序内部完成运行，通常在 Linux 系统加载运行时 shell 就被加载并驻留在系统内存中。而且解析内部命令 shell 不需要创建子进程，因此其执行速度比外部命令快。比如：history、cd、exit 等等。
**外部命令**是 Linux 系统中的实用程序部分，因为实用程序的功能通常都比较强大，所以其包含的程序量也会很大，在系统加载时并不随系统一起被加载到内存中，而是在需要时才将其调用内存。虽然其不包含在 shell 中，但是其命令执行过程是由 shell 程序控制的。

外部命令是在 Bash 之外额外安装的，通常放在/bin，/usr/bin，/sbin，/usr/sbin等等。比如：ls、vi等。
简单来说就是一个是天生自带的天赋技能，一个是后天得来附加技能。可以使用　type 命令来区分命令是内建的还是外部的。
`type exit`
`type service`
`type ls`

### 3.3.2帮助命令的使用

**help 命令**
help 命令是用于显示 shell 内建命令的简要帮助信息。对于外部命令的话基本上都有一个参数—help,这样就可以得到相应的的帮助。即
内建命令： `help [命令]`
外部命令： `[命令] –help`
如，
`help exit`
`ls –help`

**man 命令**
man没有内建与外部命令的区分，因为 man 工具是显示系统手册页中的内容，也就是一本电子版的字典，这些内容大多数都是对命令的解释信息。
`man exit`
`man ls`

**info 命令**
如果man显示的信息都还不够，可以使用info命令得到十分全面的信息。info 来自自由软件基金会的 GNU 项目，是 GNU 的超文本帮助系统，能够更完整的显示出 GNU 信息。所以得到的信息当然更多
`info ls`
简单比较这三个指令帮助命令，==help简答扼要，man详细描述，man则全面详尽==。